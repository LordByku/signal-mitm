##### Things done ###########


# Model

## Signal MITM + TLS proxy 

Alice [<------->] TLS Proxy <------> Signal Server [Opt] <------> Bob

### Assumption

	- Server to Bob not in control ( except Bob is a victim too)
	- Mitm controls the link between Alice and the server (not the server itself). Mitm proxy still comunicates with Signal Server. 

## Attacker model : active and persistent  (Dolev-Yao)
	- Get Alice to use the the fake app (fake: rogue TLS server) : social engineering IDK
	- Control Alice - Server network link (persistently) ---> Signal TLS proxy

Story : Alice is under surveillance (censorship). PlayStore Signal not available and Signal (with other messaging apps) are banned, so it uses a TLS proxy to circumvent. TLS Signal app provided by third parties( activists and so on)
Attacker: MiTM app : honest with old users which already have created the account in the past/ new users passive and active control.
### Steps:
- 1) Change app pinned certificate from Signal to my MITM proxy, so the app an work properly 

- 2) Analize every passage that happens in the vanilla app 
	- 2.1) Accept conditions and permissions (in the meanwhile, it downloads all fonts/gifs/stickers)
	- 2.2) Insert number and wait for SMS (too many request it means time before trying again) (/v1/verification/session) FCM push challenge request
	- 2.3) Insert SMS (sets attributes such as "name": null,
        "pin": null,
        "pniRegistrationId": 9634,
        "recoveryPassword": null,
        "registrationId": 4613,
        "registrationLock": null,
        "signalingKey": null,
        "unidentifiedAccessKey": "KRdIkYlZdBfyg4K9MgRiHw==",)
        
	- 2.4) Insert profile name and possible pin (can be disable) (/v2/keys/?identity=aci, /v2/keys/?identity=pni)
	
- 3) Re-create the step and swap the keys in the 2.4 step with the fake keys created.
	
	- 3.1) Everything is managed through a persistent DB since the sessions are established on the first message sent/receveid.
	
	- 3.2) Attention : the 2.4 step creates only a part of the necessary keys for the full MITM. In details, it creates the bundle needed by a potential Bob who wants to establish a communication with the 				victim. Later, it is discussed where the remaining part of the keys is generated.

- 4) As soon as the profile registration is completed, the client opens a websocket connection with the Signal server where periodically it fetches the messages (in batches). So, in the Websocket, message outgoing (/v1/messages/{destination}?story=false), incoming messages (api/v1/message), profile info (v1/profile) are handles through protobufs found on the Signal client code.

  - 4.1) PreKeySignal Messages, which are the message required to establish a new session through X3DH (type 3 messages)
   - 4.1.1) IK and EK following the X3DH protocol
   - 4.1.2) ciphertext encrypted with resulting keys from the protocol inside a Signal Message.
	- 4.2) Signal Message, which are "normal" communication messages once the handshake had been executed.
		- 4.2.1) ratchet key, needed to proceed on the protocol run.
		- 4.2.2) It contains the actual count and the previous count. It is present to avoid out-of-order messages.
		- 4.2.3) ciphertext to be decrypted.
	- 4.3) There are "special" Messages ("Alice is writing"/Bubbles, I have received/read your message, Alice is calling, Pictures) which are dealt specifically in a different way which can involve the usage of the Signal/PreKeySignal message.
	- 4.4) ciphertext is a protobuf of text, profile key and timestamp of the message creation.

- 5) Together when you send the message to establish the session, you request to the server Bob's Bundle which provides IK, SPK, OTK, which, by rule, are needed to perform the X3DH from Alice side.
	- 5.1) At this point, the Mitm intercept the request, saves the real Bob's bundle and it swaps it with a fake bundle generated on the fly. Everything saved on the DB. At this point we have all the keys to perform a full MITM attack.
- 6) Additionally, a profile can be present in different devices. Thus, Alice have to handshake with all the devices. So, the Mitm has to encrypt the message for each device. The Mitm has to save the device id and the corresponding keys.

## MITM setup

### Protocol simulation on Python3.8
The entire protocol is simulated on Python3.8. The protocol is divided in 3 main parts:
	- X3DH
	- Double Ratchet
	- Message encryption/decryption

The protocol is compatible with the Signal app present on client and server side. The exception is that it does not handle the records and state as it is done on native rust code. The protocol is implemented in a way that it can be used as a library for other projects. The protocol is tested with the official Signal app and it works properly.


 
### MITM attacks configuration:
	- passive, just decrypts messages outgoing and ingoing from Alice without changing the value of it. Still needs to decrypt and encrypt every single message passing through the wire.
	- active, swap message content but it doesn't change from the passive configuration.
